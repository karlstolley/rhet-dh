<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content="HTML Tidy for HTML5 (experimental) for Mac OS X https://github.com/w3c/tidy-html5/tree/c63cc39" />
<meta charset="UTF-8" />
<title>chapter</title>
<meta name="generator" content="iA Writer for Mac 1.5 (5591)" />
<meta name="description" content="" />
<meta name="keywords" content="" />
</head>
<body>
<h1>MVC, Materiality, and the Magus: The Rhetoric of Source-Level Production</h1>
<ul>
<li>
<p><strong>Abstract</strong> (3-5 sentences) Writing is more than a metaphor for the activity of programming. Being steeped in the digital medium’s materiality and its own kind of magic, programming provides unique rhetorical and symbolic affordances for digital humanists producing objects intended for the screens across an expanding range of devices. Model-view-controller (MVC) architecture and the development of sophisticated patterns and idioms within contemporary languages, such as Ruby and the Rails framework, provide a scaffold to initiate sustained encounters with programming.</p>
</li>
<li>
<p><strong>Keywords</strong> (3-5) programming, digital materiality, symbolic action, Ruby on Rails</p>
</li>
</ul>
<p>“The greater the range and intenseness of the opportunities for the exercising of our symbolic prowess, the greater might be our delight in such modes of action.” Kenneth Burke, “Rhetoric and Poetics,” <em>Language as Symbolic Action</em> (1966, 297)</p>
<p>Let me open with the major premise of this chapter’s argument: programming is writing. I mean that literally, as I will illustrate with some limited examples from the Ruby on Rails framework in this chapter (and a fuller companion example that can be found through this book's companion website).</p>
<p>But as literal as I mean the phrase, “programming is writing” is frequently invoked as a metaphor, even among programmers. I agree with programmer Steve McConnell (2004) who dismisses writing as “the most primitive metaphor for software development,” although there are some key points in his dismissal that are unsound. Among McConnell’s observations on the metaphor’s shortcomings:</p>
<ul>
<li>“[writing] doesn’t require any formal planning, and you figure out what you want to say as you go”</li>
<li>“writing is usually a one-person activity”</li>
<li>“in writing, a high premium is placed on originality. In software construction, [originality] is often less effective than focusing on the reuse of design ideas, code, and test cases from previous artifacts”</li>
<li>“when you finish writing a letter, you stuff it into an envelope and mail it. You can’t change it anymore”</li>
</ul>
<p>An oversimplified conception of writing forms the basis of McConnell’s critique of the metaphor. True, writing may not require formal planning, but as even the introductory-writing student quickly discovers, that’s an unstudied and ineffective way to proceed. Playwrights, poets, and technical writers alike know that writing is collaborative, to some degree, always. And from citation practices to genre features, writers have a wide foundation of reusable material upon which originality is built, given a particular rhetorical occasion: to write is to engage in intelligent, ethical (i.e., non-plagiarized) reuse of previous artifacts. However, as I discuss later, richer encounters with originality that digital writers and humanists alike might otherwise experience are routinely preempted by careless reuse and outsourcing of source-level production.</p>
<p>Granted, for certain forms of even digital writing, change becomes impossible or at least very difficult, as McConnell suggests. Digital artifacts, despite the conventional wisdom of their near-infinite mutability, typically fare worse than a snail-mailed letter. When it comes to revision and realizing the possibility of ongoing change, one-off digital invention--as in the first (and only) stab at creating a basic web page--often must suffice. There is too much risk for irreparable damage to a digital artifact when iterative revisions to its source code are both mediated and obscured by opaque point-and-click interfaces and software tools.</p>
<p>The situation is different, however, in web development frameworks such as Ruby on Rails, which I will use to illustrate some key points in this chapter (a full Rails app is available with additional commentary via this book’s companion website). To avoid a lengthy technical description of Ruby on Rails (just search the Web for it), it’s enough to say that Rails is a web development framework written in the Ruby programming language.</p>
<p>Rails can be installed, invoked, and developed entirely through writing. There is no file to manually download and unzip (as with Drupal, WordPress, and other platforms-as-frameworks that are currently popular). Rails is installed by running a command on any system with a command line (indicated here by the dollar-sign, <code>$</code>) and a Ruby installation, as in the case of Mac OS X as well as many distributions of Linux:</p>
<pre>
<code>$ gem install rails
</code>
</pre>
<p>Installing Rails does not create a Rails application. Among other things detailed below, a Rails installation includes a command-line program, conveniently called <code>rails</code>; and it is with the <code>rails</code> command that a project is brought to life from the text-based command-line interface (CLI). All that is required is a name for the project, which in this example I’ve chosen BeSocial, an imaginary social networking application:</p>
<pre>
<code>$ rails new besocial
</code>
</pre>
<p>On the command line, a bunch of output will fly by, indicating the creation of a number of directories, as well as the installation of additional software packages that Rails depends on. Two lines written on the command line have built the foundations for a web application developed in writing. In fact, running <code>rails server</code> on the command line within the new <code>besocial</code> directory fires up a web server that enables this newborn app to be viewed in a web browser at <code>http://localhost:3000</code>.</p>
<h2>Materiality</h2>
<p>When I claim that “programming is writing,” I am talking about writing source code right alongside and in service to acts of communication, including visual design and other matters for the screen. For over 30 years, point-and-click interfaces have mediated writing and other forms of digital communication. For all of the benefits of those interfaces, their mediation has also obscured much of the rich symbolic activity happening just beneath the apparent simplicity of something like an iPad’s touch screen. Digital materiality would appear to be only screen-deep.</p>
<p>Jay David Bolter’s simple 1991 observation seems all but forgotten today: “Even a graphics program does not draw: it writes.” Working at a time even before the introduction of Microsoft Windows 3.1 and the mouse-and-GUI model of interaction that that operating system would make ubiquitous, Bolter could confidently proclaim what seems tenuous today: “All computing is reading and writing. The computer is therefore a technology for all writers--scientists and engineers as well as scholars, novelists, and poets” (10).</p>
<p>Just as McConnell oversimplified the activity of writing, so too do non-programmers generally oversimplify the activity of programming. To speak of “programming” as a vague, monolithic abstraction is no different from speaking of “cooking” or even “writing.” Any sustained, personal encounter with those activities is more complex than the monolithic category itself. Although I am fascinated by books such as <em>10 PRINT</em> (Montfort et al. 2013) and certain other intellectual efforts emerging from the field software studies, it is not uncommon to encounter conference presentations and scholarship--including <em>10 PRINT</em>’s focus on a single line of BASIC--that showcase truly ancient source code. Historical treatment of source code is as important as any other history of writing and media. But it is important to note that historical examples of source code typically differ greatly from contemporary programming languages such as JavaScript, Python, or Ruby. The materiality of source code has evolved, and with it, the activity of programming.</p>
<p>It is no huge leap to reformulate Bolter’s observation as “All <em>programming</em> is reading and writing.” Of course, outside of small groups of individuals in the field of rhetoric and others in the digital humanities, the idea that “programming is writing,” and therefore counts as intellectual work, is far from accepted. It’s not possible to accept what hasn’t been widely argued and made known.</p>
<p>Ramsay and Rockwell (2012) note that, for those digital humanists “who have turned to building, hacking, and coding as part of their normal research activity,” there is a looming question of “whether the manipulation of features, objects, and states of interest using the language of coding or programming...constitutes theorizing.” Although far from arriving at any actionable answer to that question, Ramsay and Rockwell articulate the challenge that faces anyone who would claim that programming is literally writing, and therefore a mode of inquiry and intellectual work: those who program and build are compelled “to present their own activities as capable of providing affordances as rich and provocative as that of writing.”</p>
<p>The key word there is “activities”: it is neither the created artifact experienced on screen nor even the source code behind it alone that expresses the affordances of programming as intellectual work. It is the activity of programming itself that builders, writers-as-programmers must demonstrate. This activity, I believe, will ultimately present itself as “theorizing” as Ramsay and Rockwell seem to hope. But the path to theorization may look different from simply demonstrating to others a “rich and provocative” set of affordances meant to <em>metaphorically</em> suggest that “programming is writing.”</p>
<p>An approach to theorizing activity, based in rhetoric’s roots as a practical art that embraces theory as well as techne and craft, might be brought to the fore in order to help demonstrate that the practice of programming is a knowledge-generating, epistemological activity. Along these lines, Malcolm McCullough observes that</p>
<blockquote>
<p>As we overcome the residual notion that computing is for objective documentation only, we must cultivate expressive sensibilities. These may result in a digital aesthetic or poetics.... And in the end, chances are that appropriate artifacts and descriptions will engage us through rich and transparent tools, built on newfound densities of symbolic notation and personally experienced as a medium. (1996, 219)</p>
</blockquote>
<p>Unfortunately, the development of a fully realized, nuanced digital rhetoric that would account for the intellectual work of programming (i.e., the dense symbolic notation that McCullough anticipates) appears to be arrested by literary modes of knowledge-making, such as Ramsay and Rockwell’s fixation on a literary type of theorization. The screen artifact fails to demonstrate the intellectual work of programming, perhaps because screen artifacts are subject to the analysis of media historians and critics, who are closely aligned to literary modes such as close reading. The emerging field of software studies likewise concerns itself with a similar, literary reading of source code.</p>
<p>Complicating matters, the “personal experience” of a medium that McCullough calls for is preempted by the ossifying tradition of outsourcing what could otherwise be knowledge-making work in the digital humanities. Outsource programming activity to programmers, to WYSIWYG interfaces, and to readymade software packages like WordPress and Drupal, and it becomes ever more difficult to see how something like McCullough’s calls for something as lofty as a digital aesthetic or poetics will be rooted in the symbolic materiality of programming.</p>
<p>For those of us who program as a crucial part of our research agendas, then, our argument must proceed by demonstrating that programming <em>as an activity</em> is genuine, humanistic inquiry that resists denigration with regard to more established knowledge-making activities grounded in the manipulation and interpretation of symbols.</p>
<p>The need for that line of argument draws writers- and humanists-as-programmers in close company to the knowledge-making practices of art and design. In an obscure but important pamphlet published by the Royal College of Art, Christopher Frayling (1993/4) urges differentiating between three craft-/activity-oriented modes of inquiry: research <em>into</em> art and design; research <em>for</em> art and design; and research <em>through</em> art and design.</p>
<p>Rhetoric and writing, as a humanistic example, have no small body of work that researches <em>into</em> writing, often by studying writers and their contexts, such as introductory writing students in first-year composition or seasoned technical writers working in industry. The research conducted <em>for</em> writing often takes a pedagogical turn: this line of inquiry is aimed at making writing more teachable to students, rather than necessarily to improve the practice of writing itself.</p>
<p>But it is Frayling’s last prepositional category, research <em>through</em> writing and rhetoric--that is, through programming, as “personally experienced” symbolic activity--that remains a wildly undervalued mode of knowledge-making. Apart from the privileging of literary modes of inquiry I note above, there is also a problem with programming’s appearance as a mysterious and magical activity, one made all the more so by the intercession of so many screens and interfaces that enable a sanctioned, visual kind of magic--and protection from a chaotic, unpredictable textual kind of magic.</p>
<h2>Magic &amp; Programming</h2>
<p>Programming is writing. Programming is symbolic activity. To program, as to write, is to make and act in the realm of the symbolic: “making language has long been regarded as, in some sense, magical; as a <em>spell</em>” writes William Covino in <em>Magic, Rhetoric, and Literacy</em>, adding “spelling, even in its ostensibly nonmagical sense, denotes the visible materialization of invisible thought” (1994, 5).</p>
<p>Decades before Steve Jobs introduced to the world the iPad and proclaimed it to be a magical device, Arthur C. Clarke had already articulated what has become known as Clarke’s Third Law: “Any sufficiently advanced technology is indistinguishable from magic.” It is no feat of imagination to see the magic inherent in 64-bit color depths, multitouch interfaces, retina displays, and other hardware-based wonders of screens introduced over the last decade.</p>
<p>But the magical incantation of the written word in one programming language or another is what makes the symbolic activity of programming a particularly interesting problem for rhetoric and for the digital humanities more broadly. Emerging production methods such as responsive web design (RWD; see Marcotte 2010) suggest the ways in which the written word allows those who program to explore the full affordances of screens new and old.</p>
<p>Reflecting on the scene from <em>The Matrix</em> where Neo announces to Tank from inside the Construct that he needs “Guns. Lots of guns,” digital designer John Maeda describes “the sense of magic that occurs when Neo expresses his wish. The instantaneous rush of tremendous resources, as visualized in the simple special effect of this scene, epitomizes for me the experience of freedom when programming the invisible spaces of computer codes” (2004, 17).</p>
<p>While Maeda personally experiences “freedom,” of course, other people no doubt experience the fear inherent in contemplating the magical symbolic activity of programming. Fear that stems from closing ourselves off from personal experiences of the digital medium realized through programming. “Fear of magic has always been with us, in particular the fear of magic words...which claim to define or alter reality” (Covino 1994, 1). It’s no coincidence that <em>The Matrix</em> is set in a simulated/altered reality that is achieved purely by source code, which the viewer passes through in <em>The Matrix</em>’s opening title sequence.</p>
<p>Yet “Even in our nonmagical world, magic remains a conceptual construct for appraising the powers of language, and while magic is understood by some as a liberatory alternative to established rationalism, the prospect of a magical epistemology is a fearful one even for those who endorse literacy as a disruptive force” (Covino 1994, 5). Programming presents itself as magic to the uninitiated. I have witnessed that even the simple prospect of programming can arrest into silent hostility digital humanists who otherwise “endorse literacy as a disruptive force” and who ostensibly delight in an ever greater “range and intenseness” of symbolic activity (as Burke [1966] suggests in the epigraph to this chapter).</p>
<p>Covino’s treatment of magic accounts for its two different, oppositional senses. In what Covino describes as “arresting magic,” programming would indeed by conjured only by a particular magus, the programmer, whose spells and incantations (realized in technologies from word processors to smart phones) represent “the imposition of the powerful few upon the unquestioning many” (1994, 8). However, magic presents itself in another sense: “the practice of disrupting and critiquing articulate power: a (re)sorcery of spells for generating multiple perspectives.” Noting that “generative magic enters the world it questions,” however, Covino argues that generative magic is “an amplification of the possibilities for action” (8).</p>
<p>How are digital humanists, such as digital writers, to discover those possibilities for action, if not through extended personal encounters with programming that “enters the world it questions”? This is the digital humanities that I envision and pursue, situated as I am in my study of digital writing and rhetoric: research <em>through</em> programming that creates knowledge that will push the digital humanities in general, and rhetoric more specifically, into ever more nuanced conversations with regard to the symbolic action made possible by programming.</p>
<h2>Model-View-Controller</h2>
<p>Not only have the syntaxes of programming languages evolved, but so too have the paradigms and idiomatic forms within given languages. To conclude this chapter, I want to provide a brief overview of a specific software construction paradigm, model-view-controller (MVC), and the almost religious devotion to MVC inherent in the Ruby on Rails web development framework.</p>
<p>In MVC, there is a recognition of the three essential components of any digital system. The model is concerned with data in the abstract; ensuring, for example, the correct number of digits in a credit-card number. The view is concerned only with the presentation, typically visual, of the data in the model: outputting, for example, an editable field with a credit-card number--or perhaps an obscured version of the number: <code>**** **** **** 4567</code>. And finally, the controller awaits commands from a user seeking to, in this example, enter or revise a credit-card number, and perhaps ultimately make a purchase using the credit card. The controller may send data to the model, or make requests from the model for certain data that will ultimately be rendered in the view.</p>
<h2>Bibliography</h2>
<p>Bolter, Jay David. <em>Writing Space: The Computer, Hypertext, and the History of Writing</em>. Hillsdale, NJ: Lawrence Erlbaum Associates, 1991.</p>
<p>Burke, Kenneth. <em>Language as Symbolic Action: Essays on Life, Literature, and Method</em>. Berkeley, CA: University of California Press, 1966.</p>
<p>Covino, William A. <em>Magic, Rhetoric, and Literacy: An Eccentric History of the Composing Imagination</em>. Albany, NY: Statue University of New York Press, 1994.</p>
<p>Frayling, Christopher. “Reseach in Art and Design.” <em>Royal College of Art Research Papers</em> 1, no. 1 (1993/4).</p>
<p>Maeda, John. <em>Creative Code</em>. New York, NY: Thames and Hudson, 2004.</p>
<p>Marcotte, Ethan. “Responsive Web Design.” <em>A List Apart: For People Who Make Websites</em>, May 25, 2010. http://alistapart.com/article/responsive-web-design</p>
<p>McConnell, Steve. <em>Code Complete</em>. 2nd ed. Redmond, WA: Microsoft Press, 2004. Kindle edition.</p>
<p>McCullough, Malcolm. <em>Abstracting Craft: The Practiced Digital Hand</em>. Cambridge, MA: The MIT Press, 1996.</p>
<p>Montfort, Nick, Patsy Baudoin, John Bell, Ian Bogost Jeremy Douglass, Mark C. Marino, Michael Mateas Casey Reas, Mark Sample, and Noah Vawter. <em>10 PRINT CHR$(205.5+RND(1)); : GOTO 10</em>. Cambridge, MA: The MIT Press, 2013.</p>
<p>Ramsay, Stephen and Geoffrey Rockwell, “Developing Things: Notes toward an Epistemology of Building in the Digital Humanities,” in <em>Debates in the Digital Humanities</em>, edited by Matthew K. Gold. Minneapolis, MN: University of Minnesota Press, 2012. Kindle edition.</p>
</body>
</html>
